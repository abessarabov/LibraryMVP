databaseChangeLog:
  - changeSet:
      id: tbl-001-create-tables
      author: alexey
      changes:
        - createTable:
            tableName: Tag
            columns:
              - column:
                  name: TagId
                  type: BIGINT
                  autoIncrement: true
                  constraints:
                    primaryKey: true
                    primaryKeyName: PK_Tag_TagId
              - column:
                  name: Name
                  type: NVARCHAR(256)
                  constraints:
                    nullable: false

        - createTable:
            tableName: Article
            columns:
              - column:
                  name: ArticleId
                  type: BIGINT
                  autoIncrement: true
                  constraints:
                    primaryKey: true
                    primaryKeyName: PK_Article_ArticleId
              - column:
                  name: Name
                  type: NVARCHAR(256)
                  constraints:
                    nullable: false
              - column:
                  name: CreatedAt
                  type: DATETIME2
                  constraints:
                    nullable: false
              - column:
                  name: UpdatedAt
                  type: DATETIME2
              - column:
                  name: TagsHash
                  type: CHAR(64)
              - column:
                  name: Active
                  type: BIT
                  constraints:
                    nullable: false
              - column:
                  name: Status
                  type: TINYINT
                  constraints:
                    nullable: false

        - createTable:
            tableName: ArticleTag
            columns:
              - column:
                  name: ArticleId
                  type: BIGINT
                  constraints:
                    nullable: false
              - column:
                  name: TagId
                  type: BIGINT
                  constraints:
                    nullable: false
              - column:
                  name: OrderNum
                  type: INT
                  constraints:
                    nullable: false
              - column:
                  name: Active
                  type: BIT
                  constraints:
                    nullable: false

        - createTable:
            tableName: Section
            columns:
              - column:
                  name: SectionId
                  type: BIGINT
                  autoIncrement: true
                  constraints:
                    primaryKey: true
                    primaryKeyName: PK_Section_SectionId
              - column:
                  name: Name
                  type: NVARCHAR(1024)
                  constraints:
                    nullable: false
              - column:
                  name: TagsHash
                  type: CHAR(64)
                  constraints:
                    nullable: false
              - column:
                  name: Active
                  type: BIT
                  constraints:
                    nullable: false

        - createTable:
            tableName: SectionTag
            columns:
              - column:
                  name: SectionId
                  type: BIGINT
                  constraints:
                    nullable: false
              - column:
                  name: TagId
                  type: BIGINT
                  constraints:
                    nullable: false

        - createTable:
            tableName: SectionArticle
            columns:
              - column:
                  name: SectionId
                  type: BIGINT
                  constraints:
                    nullable: false
              - column:
                  name: ArticleId
                  type: BIGINT
                  constraints:
                    nullable: false
              - column:
                  name: Active
                  type: BIT
                  constraints:
                    nullable: false

        - createTable:
            tableName: ArticleEvent
            columns:
              - column:
                  name: EventId
                  type: BIGINT
                  autoIncrement: true
                  constraints:
                    primaryKey: true
                    primaryKeyName: PK_Event_EventId
              - column:
                  name: ArticleId
                  type: BIGINT
                  constraints:
                    nullable: false
              - column:
                  name: ArticleEventTypeId
                  type: TINYINT
                  constraints:
                    nullable: false
              - column:
                  name: TagsHash
                  type: CHAR(64)
                  constraints:
                    nullable: false
              - column:
                  name: TagsConcatName
                  type: NVARCHAR(1024)
                  constraints:
                    nullable: false
              - column:
                  name: CreatedAt
                  type: DATETIME2
                  constraints:
                    nullable: false

  - changeSet:
      id: pk-001-create-primary-keys
      author: alexey
      changes:
        - addPrimaryKey:
            tableName: ArticleTag
            columnNames: ArticleId, TagId
            constraintName: PK_ArticleId_TagId

        - addPrimaryKey:
            tableName: SectionTag
            columnNames: SectionId, TagId
            constraintName: PK_SectionId_TagId

        - addPrimaryKey:
            tableName: SectionArticle
            columnNames: SectionId, ArticleId
            constraintName: PK_SectionId_ArticleId

  - changeSet:
      id: fk-001-create-foreign-keys
      author: alexey
      changes:
        - addForeignKeyConstraint:
            baseTableName: ArticleTag
            baseColumnNames: TagId
            referencedTableName: Tag
            referencedColumnNames: TagId
            constraintName: FK_ArticleTag_TagId

        - addForeignKeyConstraint:
            baseTableName: ArticleTag
            baseColumnNames: ArticleId
            referencedTableName: Article
            referencedColumnNames: ArticleId
            constraintName: FK_ArticleTag_ArticleId

        - addForeignKeyConstraint:
            baseTableName: SectionTag
            baseColumnNames: TagId
            referencedTableName: Tag
            referencedColumnNames: TagId
            constraintName: FK_SectionTag_TagId

        - addForeignKeyConstraint:
            baseTableName: SectionTag
            baseColumnNames: SectionId
            referencedTableName: Section
            referencedColumnNames: SectionId
            constraintName: FK_SectionTag_SectionId

        - addForeignKeyConstraint:
            baseTableName: SectionArticle
            baseColumnNames: ArticleId
            referencedTableName: Article
            referencedColumnNames: ArticleId
            constraintName: FK_SectionArticle_ArticleId

        - addForeignKeyConstraint:
            baseTableName: SectionArticle
            baseColumnNames: SectionId
            referencedTableName: Section
            referencedColumnNames: SectionId
            constraintName: FK_SectionArticle_SectionId

  - changeSet:
      id: df-001-create-default-values
      author: alexey
      changes:
        - addDefaultValue:
            tableName: Article
            columnName: Active
            columnDataType: BIT
            defaultValueBoolean: true
            constraintName: DF_Article_Active

        - addDefaultValue:
            tableName: Article
            columnName: Status
            columnDataType: TINYINT
            defaultValueComputed: 0
            constraintName: DF_Article_Status

        - addDefaultValue:
            tableName: Article
            columnName: CreatedAt
            columnDataType: DATETIME2
            defaultValueComputed: GETUTCDATE()
            constraintName: DF_Article_CreatedAt

        - addDefaultValue:
            tableName: ArticleTag
            columnName: Active
            columnDataType: BIT
            defaultValueBoolean: true
            constraintName: DF_ArticleTag_Active

        - addDefaultValue:
            tableName: SectionArticle
            columnName: Active
            columnDataType: BIT
            defaultValueBoolean: true
            constraintName: DF_SectionArticle_Active

        - addDefaultValue:
            tableName: Section
            columnName: Active
            columnDataType: BIT
            defaultValueBoolean: true
            constraintName: DF_Section_Active

  - changeSet:
      id: type-001-create-types
      author: alexey
      changes:
        - sql:
            dbms: mssql
            stripComments: true
            splitStatements: false
            sql: |
              CREATE TYPE dbo.TagList AS TABLE
              (
                  Id   BIGINT NULL,
                  Name NVARCHAR(256) NOT NULL,
                  OrderNum INT NULL
              );
        - sql:
            dbms: mssql
            stripComments: true
            splitStatements: false
            sql: |
              CREATE TYPE dbo.BigIntValueType AS TABLE(
                 Value BIGINT NOT NULL
              );
        - sql:
            dbms: mssql
            stripComments: true
            splitStatements: false
            sql: |
              CREATE TYPE dbo.ArticleList AS TABLE
              (
                  ArticleId BIGINT,
                  ArticleEventId BIGINT,
                  TagsHash  CHAR(64),
                  TagsConcatName NVARCHAR(1024)
              );

  - changeSet:
      id: function-001-create-functions
      author: alexey
      changes:
        - sql:
            dbms: mssql
            stripComments: false
            splitStatements: false
            sql: |
                /*
                  Простая функция для вычисления хэша SHA2_256 для статьи
                */
                CREATE FUNCTION fn_GetHashByTagIdList
                (
                  @tagList TagList READONLY
                )
                RETURNS CHAR(64)
                AS
                BEGIN
                    DECLARE @concat NVARCHAR(MAX);
                    DECLARE @hash VARBINARY(32);

                    SELECT @concat = STRING_AGG(CAST(Id AS NVARCHAR(20)), ',')
                    FROM @tagList;

    
                    SET @hash = HASHBYTES('SHA2_256', @concat);

                    RETURN CONVERT(CHAR(64), @hash, 2);
                END;
        - sql:
            dbms: mssql
            stripComments: false
            splitStatements: false
            sql: |
                /*
                  Простая функция для вычисления имени раздела
                */
                CREATE FUNCTION fn_GetConcatNameByTagList
                (
                  @tagList TagList READONLY
                )
                RETURNS NVARCHAR(1024)
                AS
                BEGIN
                    DECLARE @concat NVARCHAR(MAX);

                    SELECT @concat = LEFT(STRING_AGG(T.Name, ','), 1024)
                    FROM @tagList T;

                    RETURN @concat;
                END;

  - changeSet:
      id: sp-001-create-stored-procedures
      author: alexey
      changes:
        - sql:
            dbms: mssql
            stripComments: false
            splitStatements: false
            sql: |
                /*
                  Процедура записывает событие в таблицу ArticleEvent.
                  Идея иметь чёткую последовательность событий, чтобы можно было потом использовать ArticleEventId 
                  для определения, какое событие новее при параллельной обработке, например, индексации в эластик. Если ID статьи совпадёт.
                */
                CREATE PROCEDURE [dbo].[spArticleEventInsert]
                    @articleId BIGINT, 
                    @articleEventTypeId TINYINT,
                    @createdAt DATETIME2,
                    @tagsHash CHAR(64),
                    @tagsConcatName NVARCHAR(1024)

                AS
                BEGIN
                    INSERT INTO dbo.ArticleEvent (ArticleId, ArticleEventTypeId, CreatedAt, TagsHash, TagsConcatName)
                    VALUES (@articleId, 1, @createdAt, @tagsHash, @tagsConcatName);
                END
        - sql:
            dbms: mssql
            stripComments: false
            splitStatements: false
            sql: |
                /*
                  Процедура создаёт недостающие теги в системе на основе name из TagList.
                  Результатом процедуры является список TagId, Name соответствующий входному списку
                */
                CREATE PROCEDURE [dbo].[spTagListUpsert]
                  @tags TagList READONLY
                AS
                BEGIN

                    DECLARE @tagsTable TagList;

                    MERGE dbo.Tag AS TARGET
                    USING @tags AS SOURCE
                    ON TARGET.Name = SOURCE.Name
                    WHEN NOT MATCHED THEN
                        INSERT (Name) VALUES (SOURCE.Name)
                    OUTPUT inserted.TagId, inserted.Name, NULL INTO @tagsTable;

                    INSERT INTO @tagsTable (Id, Name)
                    SELECT TagId, Name
                    FROM dbo.Tag WITH (NOLOCK)
                    WHERE Name IN (SELECT Name FROM @tags)
                      AND Name NOT IN (SELECT Name FROM @tagsTable);

                    SELECT Id, Name FROM @tagsTable ORDER BY Id;

                END;
        - sql:
            dbms: mssql
            stripComments: false
            splitStatements: false
            sql: |
                /*
                  Процедура принимает articleId и tags для работы с таблицей ArticleTag.
                  Принимает name, tags и articleId
                */
                CREATE PROCEDURE [dbo].[spArticleTagUpsert]
                  @articleId BIGINT,
                  @tags TagList READONLY
                AS
                BEGIN
                    DECLARE @articleTags BigIntValueType;

                    INSERT INTO @articleTags (Value)
                    SELECT TagId
                    FROM (
                        MERGE ArticleTag AS TARGET
                        USING @tags AS SOURCE
                        ON (TARGET.TagId = SOURCE.Id AND TARGET.ArticleId = @articleId)
                        WHEN MATCHED THEN
                            UPDATE SET TARGET.OrderNum = SOURCE.OrderNum, TARGET.Active = 1
                        WHEN NOT MATCHED BY TARGET THEN
                            INSERT (ArticleId, TagId, OrderNum) VALUES (@articleId, SOURCE.Id, SOURCE.OrderNum)
                        WHEN NOT MATCHED BY SOURCE AND TARGET.ArticleId = @articleId THEN
                            UPDATE SET TARGET.Active = 0
                        OUTPUT inserted.TagId, inserted.Active
                    ) AS MergeResult
                    WHERE MergeResult.Active = 1;

                END;
        - sql:
            dbms: mssql
            stripComments: false
            splitStatements: false
            sql: |
                /*
                  Основная хранимая процедура по управлению статьями
                  Принимает name, tags и articleId
                */
                CREATE PROCEDURE [dbo].[spArticleUpsert]
                  @name NVARCHAR(256),
                  @tags TagList READONLY,
                  @articleId BIGINT NULL = NULL
                AS
                BEGIN

                    -- секция проверок на различные бизнесс ошибки, можно их будет обрабатывать в коде
                    IF (@articleId IS NOT NULL AND NOT EXISTS(SELECT 1 FROM dbo.Article A WITH (NOLOCK) WHERE @articleId = A.ArticleId  ))
                    BEGIN
                        RAISERROR(
                            'Article with id "%I64d" does not exist.',
                            16,
                            1,
                            @articleId
                        )
                        RETURN -1
                    END
                    IF (@articleId IS NOT NULL AND EXISTS(SELECT 1 FROM dbo.Article A WITH (NOLOCK) WHERE @articleId = A.ArticleId AND A.Active = 0 ))
                    BEGIN
                        RAISERROR(
                            'Article with id "%I64d" has been deleted.',
                            16,
                            1,
                            @articleId
                        )
                        RETURN -2
                    END

                    IF (EXISTS(SELECT 1 FROM dbo.Article A WITH (NOLOCK) WHERE (@articleId IS NULL AND @name = A.Name) OR (@articleId IS NOT NULL AND  @name = A.Name AND @articleId != A.ArticleId AND A.Active = 1)))
                    BEGIN
                        RAISERROR(
                            'Article with name "%s" already exists.',
                            16,
                            1,
                            @name
                        )
                        RETURN -3
                    END

                    -- собираем текущее время
                    DECLARE @currentDateTime DATETIME2 = GETUTCDATE();
                    DECLARE @updatedAt DATETIME2 = NULL;

                    -- TODO требуется рефакторинг. Создаём пустую статью для дальнейшего обновления
                    IF (@articleId IS NOT NULL)
                    BEGIN
                        SET @updatedAt = @currentDateTime;
                    END
                    ELSE
                    BEGIN

                        INSERT INTO dbo.Article (Name) VALUES (@name)
                        SET @articleId = SCOPE_IDENTITY();
                    END

                    -- будем формировать теги
                    DECLARE @tagsTableToCreate TagList;

                    -- процедура нам создаст недостающие тэги в таблице Tag. 
                    -- оутпут процедуры - упорядоченный список тегов (Id, Name) которые соответствуют входному листу tags
                    INSERT INTO @tagsTableToCreate (Id, Name)
                    EXEC dbo.spTagListUpsert @tags;

                    -- проставляем порядок тегов, согласно входному листу tags
                    MERGE @tagsTableToCreate AS TARGET
                    USING @tags AS SOURCE
                    ON (TARGET.Name = Source.Name)
                    WHEN MATCHED THEN
                        UPDATE SET TARGET.OrderNum = Source.OrderNum;

                    -- проставляем теги для статьи в таблице ArticleTag
                    EXEC dbo.spArticleTagUpsert @articleId = @articleId, @tags = @tagsTableToCreate;

                    -- считаем хэш по последовательности тегов нашей статьи. Берем TagId
                    DECLARE @hash CHAR(64) = dbo.fn_GetHashByTagIdList(@tagsTableToCreate);
                    -- считаем имя возможного раздела для отправки в таблицу с событиями. По последовательности тегов нашей статьи. Берем TagName
                    DECLARE @concatName NVARCHAR(1024) = dbo.fn_GetConcatNameByTagList(@tagsTableToCreate);

                    -- выставляем хэш, имя, время обновления для статьи
                    -- в качестве output возвращаем данные статьи, необходимые для заполнения модели
                    MERGE dbo.Article AS TARGET
                    USING ( 
                        SELECT @hash AS SHA256Hash 
                    ) AS SOURCE
                    ON (Target.ArticleId = @articleId)
                    WHEN MATCHED THEN
                        UPDATE SET Name = @name, UpdatedAt = COALESCE(@updatedAt, UpdatedAt), TagsHash = Source.SHA256Hash
                    OUTPUT inserted.ArticleId, inserted.Active, inserted.Status, inserted.Name, INSERTED.CreatedAt, INSERTED.UpdatedAt, INSERTED.TagsHash;

                    -- в качестве output возвращаем тэги статьи
                    SELECT Id AS TagId, Name, OrderNum FROM @tagsTableToCreate ORDER BY OrderNum;

                    -- создаём событие, что статья создана, для дальнейшей индексации
                    EXEC dbo.spArticleEventInsert @articleId = @articleId, @articleEventTypeId = 1, @createdAt = @currentDateTime, @tagsHash = @hash, @tagsConcatName = @concatName;

                END;

        - sql:
            dbms: mssql
            stripComments: false
            splitStatements: false
            sql: |
                /*
                  Идея хранимой процедуры - наполнять очередь на обработку новых/обновлённых статей.
                  Принимает batch, позволяющий регулировать скорость чтения событий, а так же lastProcessedEventId
                   - lastProcessedEventId - идея хранить этот параметр локально в кэше воркера, обновлять при завершении одной итерации. 
                   - В данный момент не хранится в базе. TODO
                */
                CREATE PROCEDURE [dbo].[spGetArticlesToBeIndexed]
                    @batch INT = 100,
                    @lastProcessedEventId BIGINT
                AS
                BEGIN
                    SET NOCOUNT ON;

                    -- Батчи больше 5000 в SQL уже не оптимальны
                    IF (@batch > 4999)
                    BEGIN
                        RAISERROR(
                            'Batch size "%d" should not be more 4999.',
                            16,
                            1,
                            @batch
                        )
                        RETURN -1
                    END;

                    -- читаем события из таблицы ArticleEvent со статусом 0. Значит - это новые созданные статьи
                    -- TODO события, если статья была изменена - мы игнорируем пока тут. Логика их обработки будет в другом месте 
                    SELECT TOP(@batch)
                    E.EventId,
                    E.ArticleId,
                    E.TagsHash,
                    E.TagsConcatName,
                    E.ArticleEventTypeId,
                    E.CreatedAt
                    FROM dbo.ArticleEvent E WITH (NOLOCK)
                    INNER JOIN dbo.Article A WITH (NOLOCK) ON A.ArticleId = E.ArticleId
                    WHERE A.Status = 0 AND A.Active = 1 AND E.EventId > @lastProcessedEventId;
                END

        - sql:
            dbms: mssql
            stripComments: false
            splitStatements: false
            sql: |
                /*
                  Хранимая процедура для апдейта/вставки разделов батчами.
                  Принимает TVP ArticleList, в котором есть уже подготовленные ArticleId, TagsConcatName и TagsHash
                   - TagsConcatName - будущее имя раздела, полученные функцией 
                   - TagsHash - хэш тегов статьи
                   - ArticleId - Id новой созданной статьи
                */
                CREATE PROCEDURE dbo.spSectionUpsertBatch
                (
                    @articleList ArticleList READONLY 
                )
                AS 
                BEGIN 
                    SET NOCOUNT ON; 

                    DECLARE @sectionsToUpdate TABLE (ArticleId BIGINT, SectionId BIGINT); 
                    DECLARE @affectedSections TABLE (SectionId BIGINT);
                    DECLARE @newSections TABLE (SectionId BIGINT, ArticleId BIGINT, TagsHash CHAR(64));

                    -- на основе ArticleList по TagsHash ищем разделы, и создаём новые, если отсутствуют. 
                    -- собираем OUTPUT чтобы скопировать теги статьи в новый раздел
                    MERGE dbo.Section AS TARGET
                    USING @articleList AS SOURCE 
                    ON (TARGET.TagsHash = SOURCE.TagsHash) 
                    WHEN NOT MATCHED THEN 
                        INSERT (Name, TagsHash) VALUES (SOURCE.TagsConcatName, SOURCE.TagsHash)
                    OUTPUT inserted.SectionId, SOURCE.ArticleId, inserted.TagsHash INTO @newSections;
           
                    -- копируем теши из оригинальной статьи в таблицу SectionTag
                    INSERT INTO dbo.SectionTag (SectionId, TagId)
                    SELECT NS.SectionId, AT.TagId
                    FROM dbo.ArticleTag AT WITH (NOLOCK)
                    INNER JOIN @newSections NS ON NS.ArticleId = AT.ArticleId
                    WHERE AT.Active = 1;
                    
                    -- собираем данные по разделам, статьи которых были в этом батче для последующего их редактирования
                    -- т.к. @newSections содержит только новые разделы, нам надо получить те разделы, которым соответствую статьи в батче
                    INSERT INTO @sectionsToUpdate (ArticleId, SectionId)
                    SELECT A.ArticleId, S.SectionId 
                    FROM @articleList A
                    INNER JOIN dbo.Section S WITH (NOLOCK) ON A.TagsHash = S.TagsHash

                    -- формируем общую таблицу, которая будет содержать разделы, которые нужно обновить и новые созданные
                    INSERT INTO @affectedSections (SectionId)
                    SELECT SectionId FROM @sectionsToUpdate;

                    -- идём по существующим секциям и выставляем Active = 0, если изменилась статья, находящаяся в этом разделе
                    -- собираем ID разделов для последующей переиндексации
                    UPDATE SA
                    SET SA.Active = 0
                    OUTPUT inserted.SectionId INTO @affectedSections
                    FROM dbo.SectionArticle SA
                    INNER JOIN @sectionsToUpdate SU ON SA.ArticleId = SU.ArticleId
                    WHERE SA.SectionId != SU.SectionId AND SA.Active = 1

                    -- идём по существующим секциям и выставляем Active = 1, если статья стала соответствовать разделу и была уже отсюда перемещена
                    -- либо добавляем статью в раздел
                    -- оутпут так же собираем для переиндексации.
                    MERGE dbo.SectionArticle AS TARGET
                    USING @sectionsToUpdate AS SOURCE
                        ON TARGET.SectionId = SOURCE.SectionId
                       AND TARGET.ArticleId = SOURCE.ArticleId
                    WHEN MATCHED AND TARGET.Active = 0 THEN
                        UPDATE SET TARGET.Active = 1
                    WHEN NOT MATCHED THEN
                        INSERT (SectionId, ArticleId) VALUES (SOURCE.SectionId, SOURCE.ArticleId)
                    OUTPUT inserted.SectionId INTO @affectedSections;

                    -- выставляем Status = 1 для статей, т.к. они были нами "Проиндексированы" на уровне базы. 
                    -- статус носит предварительный характер, чтобы те же самые данные не индексировались много раз
                    UPDATE A
                    SET A.Status = 1
                    FROM dbo.Article A
                    INNER JOIN @articleList AL ON A.ArticleId = AL.ArticleId;

                    -- теперь нам надо собрать репорт для воркера, который будет содержать метаданные для дальнейшей индексации данных вне БД
                    -- мы идём по затронутым разделам, выдаём метадату раздела, считаем количество статей в нём и выдаём список тегов
                    DECLARE SectionCursor CURSOR FOR
                        SELECT S.SectionId, S.Name, S.TagsHash, S.Active
                        FROM dbo.Section S WITH (NOLOCK)
                        INNER JOIN @affectedSections T ON T.SectionId = S.SectionId
                        GROUP BY S.SectionId, S.Name, S.TagsHash, S.Active;
                    OPEN SectionCursor;

                    DECLARE @sectionId BIGINT;
                    DECLARE @name NVARCHAR(1024);
                    DECLARE @tagsHash CHAR(64);
                    DECLARE @active BIT;
                    DECLARE @articleCount INT;

                    FETCH NEXT FROM SectionCursor INTO @sectionId, @name, @tagsHash, @active;

                    WHILE @@FETCH_STATUS = 0
                    BEGIN
        
                        -- включаем каунтер, чтобы считал только статьи
                        SET NOCOUNT OFF; 

                        DECLARE @rowCount INT = 0; 

                        DECLARE @sectionArticleResult TABLE(ArticleId BIGINT, SectionId BIGINT, Active BIT, ArticleName NVARCHAR(256), CreatedAt DATETIME2, UpdatedAt DATETIME2);

                        -- сначала соберем статьи, относящиеся к разделу, чтобы посчитать их количество
                        INSERT INTO @sectionArticleResult (ArticleId, SectionId, Active, ArticleName, CreatedAt, UpdatedAt)
                        SELECT 
                            SA.ArticleId, 
                            SA.SectionId, 
                            SA.Active, 
                            A.Name AS ArticleName, 
                            A.CreatedAt, 
                            A.UpdatedAt
                        FROM dbo.SectionArticle SA WITH (NOLOCK)
                        INNER JOIN Article A WITH (NOLOCK) ON SA.ArticleId = A.ArticleId
                        WHERE SA.SectionId = @sectionId AND SA.Active = 1 AND A.Active = 1;

                        SET @rowCount = @@ROWCOUNT;

                        -- выводим метаданные раздела + добавляем самый последний из пришедших ArticleEventId для версионирования в дальнейшем
                        SELECT 
                        @sectionId   AS SectionId, 
                        @name        AS Name, 
                        @tagsHash    AS TagsHash, 
                        @active      AS Active, 
                        @rowCount    AS ArticleCount,
                        (
                            SELECT MAX(AL.ArticleEventId)
                            FROM @articleList AL
                            WHERE AL.TagsHash = @tagsHash
                        ) AS ArticleEventId;

                        -- выводим данные по статьям + добавляем ArticleEventId для версионирования в дальнейшем.
                        SELECT AL.ArticleEventId, SA.ArticleId, SA.SectionId, SA.Active, SA.ArticleName, SA.CreatedAt, SA.UpdatedAt
                        FROM @sectionArticleResult SA
                        INNER JOIN @articleList AL ON SA.ArticleId = AL.ArticleId;

                        -- отключаем каунтер, чтобы считал только статьи
                        SET NOCOUNT ON; 

                        -- выводи данные по тегам статьи
                        SELECT SA.SectionId, SA.TagId, T.Name AS TagName
                        FROM dbo.SectionTag SA WITH (NOLOCK)
                        INNER JOIN dbo.Tag T WITH (NOLOCK) ON SA.TagId = T.TagId
                        WHERE SA.SectionId = @sectionId;

                        DELETE FROM @sectionArticleResult;

                        FETCH NEXT FROM SectionCursor INTO @sectionId, @name, @tagsHash, @active;
                    END
    
                    CLOSE SectionCursor;
                    DEALLOCATE SectionCursor;

                END;

        - sql:
            dbms: mssql
            stripComments: false
            splitStatements: false
            sql: |
                /*
                  Хранимая процедура для получения статьи и тэгов статьи
                */
                CREATE PROCEDURE dbo.spArticleGetById
                   @articleId BIGINT
                AS
                BEGIN
 
                    SET NOCOUNT ON;

                    SELECT 
                    A.ArticleId, 
                    A.Name,
                    A.Active,
                    A.Status,
                    A.CreatedAt, 
                    A.UpdatedAt, 
                    A.TagsHash 
                    FROM dbo.Article A WITH (NOLOCK) 
                    WHERE A.Active = 1 AND A.ArticleId = @articleId;

                    SELECT AT.TagId, T.Name, AT.OrderNum 
                    FROM dbo.ArticleTag AT WITH (NOLOCK)
                    INNER JOIN Tag T WITH (NOLOCK) ON T.TagId = AT.TagId
                    WHERE AT.Active = 1 AND AT.ArticleId = @articleId
                    ORDER BY AT.OrderNum;

                END
        - sql:
            dbms: mssql
            stripComments: false
            splitStatements: false
            sql: |
                /*
                  Хранимая процедура для получения тэгов по tagIds. Может понадобиться для Resolve Tags, 
                  так как держать имена тегов в памяти не оптимально, можно кэшировать на стороне сервиса
                */
                CREATE PROCEDURE dbo.spTagGetByIds
                  @tagIds BigIntValueType READONLY
                AS
                BEGIN
                    SET NOCOUNT ON;

                    SELECT TagId, Name
                    FROM dbo.Tag T WITH (NOLOCK)
                    INNER JOIN @tagIds S ON S.Value = T.TagId;
                END
